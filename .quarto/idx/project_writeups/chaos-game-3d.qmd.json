{"title":"Advanced Data Visualization: A 2D Chaos Game Played in 3 Dimensions","markdown":{"yaml":{"title":"Advanced Data Visualization: A 2D Chaos Game Played in 3 Dimensions","format":{"html":{"body-classes":"project-page"}}},"headingText":"Advanced Data Visualization: A 2D Chaos Game Played in 3 Dimensions","containsRefs":false,"markdown":"\n\n\n**Project description:** The chaos game is one of the classic geometric introductions into chaos theory. I always found it more beautiful than other simple examples like a double pendulum. Creating a Sierpinski triangle is extremely easy but I couldn't find an implementation in R into 3 dimensions. R is not the best programming language to generate dense 3D fractal point clouds but I thought it would be a fun exercise in optimization to see if I could not only build a 3D version of the 2D chaos game but also get it to render quickly in R. Additionally, I wanted to generalize the 2D chaos game, so rather than the traditional method of subtracting volumes, I wanted to calculate a 2D Sierpinski triangle over each face over a 3D Sierpinski Pyramid. If you want to skip straight to the final result click the link below to see an interactive R shiny app:\n\n[2D Chaos Game in 3D](https://edwardarchaeology.shinyapps.io/3DChaosGameApp/)\n\n### The Chaos Game in 2D\n\nThe Chaos Game is a simple method of generating 2D fractals using a regular polygon. In the triangular case you choose a random point within an equilateral triangle, choose a random vertex, calculate the midpoint between that vertex and the random point, and repeat this using that midpoint as your new random point. After some number of iterations N, your points will begin to show a Sierpinski triangle like the one below:\n\n<video class=\"project-thumb\" controls autoplay muted loop playsinline>\n  <source src=\"../assets/project_videos/pyramid/triangle.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>\n\nIn pseudocode this would look like:\n\n```\n1. Initialize:\n   - Set the vertices of the triangle: A, B, C\n   - Choose a starting point randomly within the triangle (P)\n\n2. Set the number of iterations (N) for the algorithm\n\n3. Repeat N times:\n   a. Choose one of the vertices (A, B, C) randomly\n   b. Move the current point (P) halfway towards the chosen vertex\n   c. Update the current point (P) to this new position\n\n4. Plot the points (P) as they are generated\n\n5. Display the plot to visualize the Sierpiński triangle\nTry out the app here. [Waffle House Index Simulator](https://edwardarchaeology.shinyapps.io/app_testing/)\n```\n### A 3D Chaos Game\nFor my project I wanted to generalize this to 3D which required working with four sided triangular tetrahedrons. The process is quite similar to the 2D case. To start you create a regular triangular tetrahedron, you choose a random point and random vertex, and do the whole midpoint calculation process again. The pseudocode for this is below: \n\n```\n1. Initialize:\n   - Define the vertices of the tetrahedron: A, B, C, D\n   - Choose a random starting point (P) within the tetrahedron\n\n2. Set the number of iterations (N) for the algorithm\n\n3. Repeat N times:\n   a. Randomly select one of the vertices (A, B, C, D)\n   b. Move the current point (P) halfway towards the chosen vertex\n   c. Update the current point (P) to this new position\n\n4. Plot the points (P) as they are generated\n\n5. Display the plot to visualize the 3D fractal\n```\n\n### A 2D Chaos Game Played in 3D?\nI quickly built both of these but found them kind of boring. I decided to go a little off the rails and iteratively play the 2D chaos game in 3D. To do this, I took the tetrahedron and calculated the midpoint along all of its edges. I created four subtetrahedrons using each vertex in combination with the three midpoints of its associated edges. I recursively iterated through this process to some arbitrary depth. This resulted in a massive list of all the vertices for each subtetrahedron the the original tetrahedron. From here I could play the 2D chaos game along each of the four faces of each subtetrahedron. This results in a \"hollow\" Sierpinski Pyramid with chaotic points delineating its faces. Now, the way I've implemented this was just for my own interest in the 2D chaos game being used to create a 3D fractal but the vertex generation procedure could easily be used to generate a triangular mesh over the vertex sets. This could be a fast way to generate 3D fractals as polygonal meshes. A small visual representation of the process and the pseudocode for my method are below:\n\n<video class=\"project-thumb\" controls autoplay muted loop playsinline>\n  <source src=\"../assets/project_videos/pyramid/3D.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>\n\n\n```\nFunction Main():\n    // Initial tetrahedron vertices\n    A = (ax, ay, az)\n    B = (bx, by, bz)\n    C = (cx, cy, cz)\n    D = (dx, dy, dz)\n    \n    // Define recursion depth\n    maxDepth = d\n    \n    // List to store vertices of all subtetrahedrons\n    allVertices = []\n\n    // Start the recursive subdivision\n    RecursiveSubdivision(A, B, C, D, 0, maxDepth, allVertices)\n    \n    // Apply 2D Chaos Game on each face of each subtetrahedron\n    For each tetrahedron in allVertices:\n        Apply2DChaosGameOnTetrahedronFaces(tetrahedron)\n    \nEnd Function\n\nFunction RecursiveSubdivision(A, B, C, D, currentDepth, maxDepth, allVertices):\n    // Base case: if maximum depth reached, add vertices to list\n    If currentDepth == maxDepth:\n        allVertices.append((A, B, C, D))\n        Return\n    \n    // Calculate midpoints of all edges\n    M_AB = Midpoint(A, B)\n    M_AC = Midpoint(A, C)\n    M_AD = Midpoint(A, D)\n    M_BC = Midpoint(B, C)\n    M_BD = Midpoint(B, D)\n    M_CD = Midpoint(C, D)\n    \n    // Create four new subtetrahedrons\n    SubTetra1 = (A, M_AB, M_AC, M_AD)\n    SubTetra2 = (B, M_AB, M_BC, M_BD)\n    SubTetra3 = (C, M_AC, M_BC, M_CD)\n    SubTetra4 = (D, M_AD, M_BD, M_CD)\n    \n    // Recursively subdivide each new subtetrahedron\n    RecursiveSubdivision(SubTetra1[1], SubTetra1[2], SubTetra1[3], SubTetra1[4], currentDepth + 1, maxDepth, allVertices)\n    RecursiveSubdivision(SubTetra2[1], SubTetra2[2], SubTetra2[3], SubTetra2[4], currentDepth + 1, maxDepth, allVertices)\n    RecursiveSubdivision(SubTetra3[1], SubTetra3[2], SubTetra3[3], SubTetra3[4], currentDepth + 1, maxDepth, allVertices)\n    RecursiveSubdivision(SubTetra4[1], SubTetra4[2], SubTetra4[3], SubTetra4[4], currentDepth + 1, maxDepth, allVertices)\n\nEnd Function\n\nFunction Midpoint(P1, P2):\n    // Calculate the midpoint between two points in 3D space\n    Return ((P1.x + P2.x) / 2, (P1.y + P2.y) / 2, (P1.z + P2.z) / 2)\nEnd Function\n\nFunction Apply2DChaosGameOnTetrahedronFaces(tetrahedron):\n    // Extract vertices of the tetrahedron\n    (A, B, C, D) = tetrahedron\n    \n    // Apply 2D Chaos Game to each face (triangle) of the tetrahedron\n    Apply2DChaosGame(A, B, C)\n    Apply2DChaosGame(A, B, D)\n    Apply2DChaosGame(A, C, D)\n    Apply2DChaosGame(B, C, D)\nEnd Function\n\nFunction Apply2DChaosGame(A, B, C):\n    // Implement the 2D Chaos Game on a triangular face defined by vertices A, B, and C\n    // (This involves a similar process as the traditional 2D Chaos Game, generating points within the triangle)\n    // Initialize a random point within the triangle\n    P = RandomPointInTriangle(A, B, C)\n    \n    // Define the number of iterations\n    N = 10000  // Arbitrary number for illustration\n    \n    // Iteratively generate points\n    For i from 1 to N:\n        // Randomly select one of the vertices\n        Vertex = RandomChoice([A, B, C])\n        \n        // Move the current point halfway towards the chosen vertex\n        P = Midpoint(P, Vertex)\n        \n        // Store or plot the point as needed\n        PlotPoint(P)  // This function would plot or store the point for visualization\n    \nEnd Function\n```\n\nThis all resulted in the creation of a shiny app to show off the results of this kind of insane process. Check it out via the link below but be warned, depths 4 and 5 take a long time to render if you have a lot of points:\n\n[2D Chaos Game in 3D](https://edwardarchaeology.shinyapps.io/3DChaosGameApp/)\n","srcMarkdownNoYaml":"\n\n## Advanced Data Visualization: A 2D Chaos Game Played in 3 Dimensions\n\n**Project description:** The chaos game is one of the classic geometric introductions into chaos theory. I always found it more beautiful than other simple examples like a double pendulum. Creating a Sierpinski triangle is extremely easy but I couldn't find an implementation in R into 3 dimensions. R is not the best programming language to generate dense 3D fractal point clouds but I thought it would be a fun exercise in optimization to see if I could not only build a 3D version of the 2D chaos game but also get it to render quickly in R. Additionally, I wanted to generalize the 2D chaos game, so rather than the traditional method of subtracting volumes, I wanted to calculate a 2D Sierpinski triangle over each face over a 3D Sierpinski Pyramid. If you want to skip straight to the final result click the link below to see an interactive R shiny app:\n\n[2D Chaos Game in 3D](https://edwardarchaeology.shinyapps.io/3DChaosGameApp/)\n\n### The Chaos Game in 2D\n\nThe Chaos Game is a simple method of generating 2D fractals using a regular polygon. In the triangular case you choose a random point within an equilateral triangle, choose a random vertex, calculate the midpoint between that vertex and the random point, and repeat this using that midpoint as your new random point. After some number of iterations N, your points will begin to show a Sierpinski triangle like the one below:\n\n<video class=\"project-thumb\" controls autoplay muted loop playsinline>\n  <source src=\"../assets/project_videos/pyramid/triangle.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>\n\nIn pseudocode this would look like:\n\n```\n1. Initialize:\n   - Set the vertices of the triangle: A, B, C\n   - Choose a starting point randomly within the triangle (P)\n\n2. Set the number of iterations (N) for the algorithm\n\n3. Repeat N times:\n   a. Choose one of the vertices (A, B, C) randomly\n   b. Move the current point (P) halfway towards the chosen vertex\n   c. Update the current point (P) to this new position\n\n4. Plot the points (P) as they are generated\n\n5. Display the plot to visualize the Sierpiński triangle\nTry out the app here. [Waffle House Index Simulator](https://edwardarchaeology.shinyapps.io/app_testing/)\n```\n### A 3D Chaos Game\nFor my project I wanted to generalize this to 3D which required working with four sided triangular tetrahedrons. The process is quite similar to the 2D case. To start you create a regular triangular tetrahedron, you choose a random point and random vertex, and do the whole midpoint calculation process again. The pseudocode for this is below: \n\n```\n1. Initialize:\n   - Define the vertices of the tetrahedron: A, B, C, D\n   - Choose a random starting point (P) within the tetrahedron\n\n2. Set the number of iterations (N) for the algorithm\n\n3. Repeat N times:\n   a. Randomly select one of the vertices (A, B, C, D)\n   b. Move the current point (P) halfway towards the chosen vertex\n   c. Update the current point (P) to this new position\n\n4. Plot the points (P) as they are generated\n\n5. Display the plot to visualize the 3D fractal\n```\n\n### A 2D Chaos Game Played in 3D?\nI quickly built both of these but found them kind of boring. I decided to go a little off the rails and iteratively play the 2D chaos game in 3D. To do this, I took the tetrahedron and calculated the midpoint along all of its edges. I created four subtetrahedrons using each vertex in combination with the three midpoints of its associated edges. I recursively iterated through this process to some arbitrary depth. This resulted in a massive list of all the vertices for each subtetrahedron the the original tetrahedron. From here I could play the 2D chaos game along each of the four faces of each subtetrahedron. This results in a \"hollow\" Sierpinski Pyramid with chaotic points delineating its faces. Now, the way I've implemented this was just for my own interest in the 2D chaos game being used to create a 3D fractal but the vertex generation procedure could easily be used to generate a triangular mesh over the vertex sets. This could be a fast way to generate 3D fractals as polygonal meshes. A small visual representation of the process and the pseudocode for my method are below:\n\n<video class=\"project-thumb\" controls autoplay muted loop playsinline>\n  <source src=\"../assets/project_videos/pyramid/3D.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag.\n</video>\n\n\n```\nFunction Main():\n    // Initial tetrahedron vertices\n    A = (ax, ay, az)\n    B = (bx, by, bz)\n    C = (cx, cy, cz)\n    D = (dx, dy, dz)\n    \n    // Define recursion depth\n    maxDepth = d\n    \n    // List to store vertices of all subtetrahedrons\n    allVertices = []\n\n    // Start the recursive subdivision\n    RecursiveSubdivision(A, B, C, D, 0, maxDepth, allVertices)\n    \n    // Apply 2D Chaos Game on each face of each subtetrahedron\n    For each tetrahedron in allVertices:\n        Apply2DChaosGameOnTetrahedronFaces(tetrahedron)\n    \nEnd Function\n\nFunction RecursiveSubdivision(A, B, C, D, currentDepth, maxDepth, allVertices):\n    // Base case: if maximum depth reached, add vertices to list\n    If currentDepth == maxDepth:\n        allVertices.append((A, B, C, D))\n        Return\n    \n    // Calculate midpoints of all edges\n    M_AB = Midpoint(A, B)\n    M_AC = Midpoint(A, C)\n    M_AD = Midpoint(A, D)\n    M_BC = Midpoint(B, C)\n    M_BD = Midpoint(B, D)\n    M_CD = Midpoint(C, D)\n    \n    // Create four new subtetrahedrons\n    SubTetra1 = (A, M_AB, M_AC, M_AD)\n    SubTetra2 = (B, M_AB, M_BC, M_BD)\n    SubTetra3 = (C, M_AC, M_BC, M_CD)\n    SubTetra4 = (D, M_AD, M_BD, M_CD)\n    \n    // Recursively subdivide each new subtetrahedron\n    RecursiveSubdivision(SubTetra1[1], SubTetra1[2], SubTetra1[3], SubTetra1[4], currentDepth + 1, maxDepth, allVertices)\n    RecursiveSubdivision(SubTetra2[1], SubTetra2[2], SubTetra2[3], SubTetra2[4], currentDepth + 1, maxDepth, allVertices)\n    RecursiveSubdivision(SubTetra3[1], SubTetra3[2], SubTetra3[3], SubTetra3[4], currentDepth + 1, maxDepth, allVertices)\n    RecursiveSubdivision(SubTetra4[1], SubTetra4[2], SubTetra4[3], SubTetra4[4], currentDepth + 1, maxDepth, allVertices)\n\nEnd Function\n\nFunction Midpoint(P1, P2):\n    // Calculate the midpoint between two points in 3D space\n    Return ((P1.x + P2.x) / 2, (P1.y + P2.y) / 2, (P1.z + P2.z) / 2)\nEnd Function\n\nFunction Apply2DChaosGameOnTetrahedronFaces(tetrahedron):\n    // Extract vertices of the tetrahedron\n    (A, B, C, D) = tetrahedron\n    \n    // Apply 2D Chaos Game to each face (triangle) of the tetrahedron\n    Apply2DChaosGame(A, B, C)\n    Apply2DChaosGame(A, B, D)\n    Apply2DChaosGame(A, C, D)\n    Apply2DChaosGame(B, C, D)\nEnd Function\n\nFunction Apply2DChaosGame(A, B, C):\n    // Implement the 2D Chaos Game on a triangular face defined by vertices A, B, and C\n    // (This involves a similar process as the traditional 2D Chaos Game, generating points within the triangle)\n    // Initialize a random point within the triangle\n    P = RandomPointInTriangle(A, B, C)\n    \n    // Define the number of iterations\n    N = 10000  // Arbitrary number for illustration\n    \n    // Iteratively generate points\n    For i from 1 to N:\n        // Randomly select one of the vertices\n        Vertex = RandomChoice([A, B, C])\n        \n        // Move the current point halfway towards the chosen vertex\n        P = Midpoint(P, Vertex)\n        \n        // Store or plot the point as needed\n        PlotPoint(P)  // This function would plot or store the point for visualization\n    \nEnd Function\n```\n\nThis all resulted in the creation of a shiny app to show off the results of this kind of insane process. Check it out via the link below but be warned, depths 4 and 5 take a long time to render if you have a lot of points:\n\n[2D Chaos Game in 3D](https://edwardarchaeology.shinyapps.io/3DChaosGameApp/)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"body-classes":"project-page"},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":false,"output-file":"chaos-game-3d.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","smooth-scroll":true,"theme":{"light":["cosmo","../assets/scripts/custom.scss"],"dark":["cosmo","../assets/scripts/custom.scss"]},"includes":{"after-body":"../assets/scripts/fit-title.html"},"page-layout":"full","title":"Advanced Data Visualization: A 2D Chaos Game Played in 3 Dimensions"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}